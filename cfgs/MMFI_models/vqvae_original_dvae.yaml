# MMFI数据集VQ-VAE训练配置 - 方案4：原本dVAE损失
# 与原始dVAE完全一致的损失函数（Chamfer + KL散度）

optimizer : {
  type: AdamW,
  kwargs: {
  lr : 0.00001,  # 降低学习率
  weight_decay : 0.00001
}}

scheduler: {
  type: CosLR,
  kwargs: {
    epochs: 200,  # 骨架数据需要更多epoch学习时序模式
    initial_epochs : 20,
    warming_up_init_lr: 0.00001
}}

# VQ-VAE特有参数 - 不需要温度退火
vq_params: {
  commitment_cost: 0.25,  # VQ-VAE的承诺损失权重
  codebook_size: 1024,    # 码本大小，适合骨架动作的离散表示
  embedding_dim: 256      # 嵌入向量维度
}

# KL权重调度（如果使用混合方法）
kldweight: {
  start : 0,
  target: 0.05,  # 与原本dVAE保持一致的KL权重
  ntime: 50000
}

dataset : {
  train : { _base_: cfgs/dataset_configs/MMFI.yaml, 
            others: {subset: 'train'}},
  val : { _base_: cfgs/dataset_configs/MMFI.yaml, 
            others: {subset: 'val'}},
  test : { _base_: cfgs/dataset_configs/MMFI.yaml, 
            others: {subset: 'test'}}
}

model : {
  NAME: AdaptiveSkeletonDVAE,  # 使用自适应骨架DVAE
  latent_dim: 512,      # 潜在空间维度
  num_tokens: 1024,     # 码本大小 
  commitment_cost: 0.25, # VQ承诺损失权重
  loss_type: original_dvae  # 方案4：使用原本dVAE的损失函数
}

# 训练配置
total_bs : 32         # 骨架数据可以使用较大batch size
step_per_update : 1
max_epoch : 100       # 增加训练轮数

# 硬件和验证设置
use_gpu: true
val_freq: 10
save_freq: 20

# 日志和实验配置
experiment_name: "MMFI_skeleton_vqvae_original_dvae"
log_dir: "logs/mmfi_vqvae_original_dvae"
checkpoint_dir: "experiments/vqvae/MMFI_models"

# 损失权重配置
loss_weights: {
  recon_loss: 1.0,      # 重建损失（Chamfer距离）
  vq_loss: 1.0,         # KL散度损失（与原本dVAE一致）
  action_loss: 0.3      # 动作分类损失（如果启用）
}

# 数据增强配置
data_augmentation: {
  enable: true,
  noise_std: 0.01,      # 添加小量噪声
  temporal_shift: true, # 时序偏移
  joint_dropout: 0.1    # 关节丢弃
}

# 评估配置
evaluation: {
  metrics: ["chamfer_l1", "kl_divergence", "codebook_usage", "perplexity"],
  save_reconstructions: true,
  save_codes: true
}

# 主要评估指标（用于模型选择）
consider_metric: CDL1  # 使用Chamfer距离L1作为主要指标（与原本dVAE一致）

# 方案说明
loss_strategy: {
  name: "Original dVAE Loss Function",
  description: "与原始dVAE完全一致的损失函数，使用Chamfer距离重建损失和KL散度正则化",
  advantages: [
    "与原始dVAE框架完全一致",
    "coarse + fine双重重建损失",
    "KL散度促进码本利用",
    "经过验证的有效方法"
  ],
  disadvantages: [
    "不考虑骨架关节对应关系",
    "计算开销较大",
    "可能不适合骨架数据特性"
  ],
  use_cases: [
    "与原始Point-BERT/dVAE结果对比",
    "作为baseline验证其他方案",
    "保持与现有文献的一致性"
  ],
  technical_details: {
    "recon_loss": "Chamfer_L1(coarse, gt) + Chamfer_L1(fine, gt)",
    "regularization": "KL_divergence(q(y), uniform_distribution)",
    "optimization_target": "形状重建 + 码本正则化"
  }
}
